



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Atticus's Docs">
      
      
        <link rel="canonical" href="https://atticuslab.com/kit/paper/">
      
      
        <meta name="author" content="Atticus">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.3">
    
    
      
        <title>临时草稿纸📃 - Stack Pub</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.30686662.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans:300,400,400i,700|Fira+Mono&display=fallback">
        <style>body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
      <link rel="manifest" href="../../manifest.webmanifest">
    
    
      <link rel="stylesheet" href="../../_static/css/extra.css?v=12">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="pink">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#c-primer" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://atticuslab.com" title="Stack Pub" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Stack Pub
            </span>
            <span class="md-header-nav__topic">
              
                临时草稿纸📃
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/opfanswyx/StackPub/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Atticus/Stack Pub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../.." class="md-tabs__link">
          简介
        </a>
      
    </li>
  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../cprogram/c_base/" class="md-tabs__link">
          编程语言
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../algorithm/task/" class="md-tabs__link">
          数据结构与算法
        </a>
      
    </li>
  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../os/linux/linux_command/" class="md-tabs__link">
          操作系统
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../network/plan/" class="md-tabs__link">
          计算机网络
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../database/plan/" class="md-tabs__link">
          数据库
        </a>
      
    </li>
  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../source/nginx/nginx_base/" class="md-tabs__link">
          开源项目
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../math/math_graph/" class="md-tabs__link">
          数学
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../unity/List/" class="md-tabs__link">
          图形学
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../leetcode/1.two-sum/" class="md-tabs__link">
          LeetCode
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" class="md-tabs__link md-tabs__link--active">
          经验总结🔧
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://atticuslab.com" title="Stack Pub" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Stack Pub
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/opfanswyx/StackPub/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Atticus/Stack Pub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../.." title="Hello Wolrd" class="md-nav__link">
      Hello Wolrd
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../index/blogroll/" title="学习资源" class="md-nav__link">
      学习资源
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../index/book/" title="书籍推荐📚" class="md-nav__link">
      书籍推荐📚
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../index/theme/" title="主题修改" class="md-nav__link">
      主题修改
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../index/version/" title="F.A.Q" class="md-nav__link">
      F.A.Q
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      编程语言
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        编程语言
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1">
    
    <label class="md-nav__link" for="nav-2-1">
      C语言
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-1">
        C语言
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_base/" title="C语言基础" class="md-nav__link">
      C语言基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_object/" title="C语言与面向对象" class="md-nav__link">
      C语言与面向对象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-1-3" type="checkbox" id="nav-2-1-3">
    
    <label class="md-nav__link" for="nav-2-1-3">
      C语言设计模式
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-2-1-3">
        C语言设计模式
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_design/c_state/" title="状态模式" class="md-nav__link">
      状态模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_design/c_template/" title="模板方法模式" class="md-nav__link">
      模板方法模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_design/c_observer/" title="观察者模式" class="md-nav__link">
      观察者模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_design/c_chain/" title="责任链模式" class="md-nav__link">
      责任链模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cprogram/c_design/c_visitor/" title="访问者模式" class="md-nav__link">
      访问者模式
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/regexp/" title="正则表达式" class="md-nav__link">
      正则表达式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/shell/" title="Shell编程" class="md-nav__link">
      Shell编程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4" type="checkbox" id="nav-2-4">
    
    <label class="md-nav__link" for="nav-2-4">
      C Plus Plus
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-4">
        C Plus Plus
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/c++_primer/" title="C++ Primer总结" class="md-nav__link">
      C++ Primer总结
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_1base/" title="C++基础" class="md-nav__link">
      C++基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_2object/" title="类和对象" class="md-nav__link">
      类和对象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_3quote/" title="引用" class="md-nav__link">
      引用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_4inher/" title="继承与派生" class="md-nav__link">
      继承与派生
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_5polym/" title="多态与虚函数" class="md-nav__link">
      多态与虚函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_6ysfcz/" title="运算符重载" class="md-nav__link">
      运算符重载
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_7template/" title="模板" class="md-nav__link">
      模板
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_8catch/" title="异常" class="md-nav__link">
      异常
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4-10" type="checkbox" id="nav-2-4-10">
    
    <label class="md-nav__link" for="nav-2-4-10">
      STL
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-2-4-10">
        STL
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl/" title="STL基础" class="md-nav__link">
      STL基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_vector/" title="vector" class="md-nav__link">
      vector
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_list/" title="list" class="md-nav__link">
      list
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_deque/" title="deque" class="md-nav__link">
      deque
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_funcobject/" title="函数对象" class="md-nav__link">
      函数对象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_pair/" title="关联容器与pair类模板" class="md-nav__link">
      关联容器与pair类模板
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_multiset/" title="multiset" class="md-nav__link">
      multiset
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_set/" title="set" class="md-nav__link">
      set
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_multimap/" title="multimap" class="md-nav__link">
      multimap
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_map/" title="map" class="md-nav__link">
      map
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_stack/" title="stack" class="md-nav__link">
      stack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_queue/" title="queue和priority_queue" class="md-nav__link">
      queue和priority_queue
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_algo/" title="STL算法分类" class="md-nav__link">
      STL算法分类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_string/" title="string类" class="md-nav__link">
      string类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/stl/cpp_stl_bitset/" title="bitset类" class="md-nav__link">
      bitset类
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_9io/" title="输入输出流" class="md-nav__link">
      输入输出流
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_10file/" title="文件操作" class="md-nav__link">
      文件操作
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../cplus/cpp_11high/" title="高级主题" class="md-nav__link">
      高级主题
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-5" type="checkbox" id="nav-2-5">
    
    <label class="md-nav__link" for="nav-2-5">
      Go语言
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-5">
        Go语言
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../goprogram/go_base/" title="Go语言基础" class="md-nav__link">
      Go语言基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../goprogram/go_oop/" title="Go语言面向对象相关" class="md-nav__link">
      Go语言面向对象相关
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../goprogram/plan/" title="规划" class="md-nav__link">
      规划
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-6" type="checkbox" id="nav-2-6">
    
    <label class="md-nav__link" for="nav-2-6">
      PHP
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-6">
        PHP
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/php/php_base/" title="PHP基础" class="md-nav__link">
      PHP基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/php/php_object/" title="PHP面向对象" class="md-nav__link">
      PHP面向对象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/php/php_web/" title="PHP WEB相关" class="md-nav__link">
      PHP WEB相关
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/lua/lua_summary/" title="Lua总结" class="md-nav__link">
      Lua总结
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      数据结构与算法
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        数据结构与算法
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/task/" title="本模块规划" class="md-nav__link">
      本模块规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-2" type="checkbox" id="nav-3-2">
    
    <label class="md-nav__link" for="nav-3-2">
      链表
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-3-2">
        链表
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_seqlist/" title="顺序链表" class="md-nav__link">
      顺序链表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_linklist/" title="链式链表" class="md-nav__link">
      链式链表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_listfunction/" title="链表的各种操作" class="md-nav__link">
      链表的各种操作
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_dlist/" title="双向链表" class="md-nav__link">
      双向链表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_clist/" title="循环♻️链表" class="md-nav__link">
      循环♻️链表
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_stack_queue/" title="栈与队列" class="md-nav__link">
      栈与队列
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_tree/" title="树🌲" class="md-nav__link">
      树🌲
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/struct_graph/" title="图" class="md-nav__link">
      图
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_pattern/" title="模式匹配" class="md-nav__link">
      模式匹配
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_sort/" title="排序" class="md-nav__link">
      排序
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_sort/" title="查找" class="md-nav__link">
      查找
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_sort/" title="数据压缩" class="md-nav__link">
      数据压缩
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_sort/" title="内存管理" class="md-nav__link">
      内存管理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../algorithm/algo_sort/" title="动态规划" class="md-nav__link">
      动态规划
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      操作系统
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        操作系统
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4-1" type="checkbox" id="nav-4-1">
    
    <label class="md-nav__link" for="nav-4-1">
      Linux
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-4-1">
        Linux
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../os/linux/linux_command/" title="Linux常用命令" class="md-nav__link">
      Linux常用命令
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../os/linux/linux_program/" title="Linux编程基础" class="md-nav__link">
      Linux编程基础
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4-2" type="checkbox" id="nav-4-2">
    
    <label class="md-nav__link" for="nav-4-2">
      CSAPP NOTE
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-4-2">
        CSAPP NOTE
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../os/csapp/plan/" title="规划" class="md-nav__link">
      规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../os/csapp/chapter1/" title="计算机系统漫游" class="md-nav__link">
      计算机系统漫游
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      计算机网络
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        计算机网络
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../network/plan/" title="规划" class="md-nav__link">
      规划
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      数据库
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        数据库
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../database/plan/" title="规划" class="md-nav__link">
      规划
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      开源项目
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        开源项目
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-1" type="checkbox" id="nav-7-1">
    
    <label class="md-nav__link" for="nav-7-1">
      Nginx
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-1">
        Nginx
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/nginx/nginx_base/" title="Nginx安装与基本配置" class="md-nav__link">
      Nginx安装与基本配置
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/nginx/nginx_web/" title="Web服务搭建与模块化配置" class="md-nav__link">
      Web服务搭建与模块化配置
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/nginx/nginx_balence/" title="负载均衡与缓存" class="md-nav__link">
      负载均衡与缓存
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/nginx/nginx_high/" title="高可用负载均衡集群" class="md-nav__link">
      高可用负载均衡集群
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7-2" type="checkbox" id="nav-7-2">
    
    <label class="md-nav__link" for="nav-7-2">
      Redis
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-7-2">
        Redis
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/redis/redis_base/" title="Redis基础" class="md-nav__link">
      Redis基础
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../source/tinyhttpd/" title="TinyHttpd" class="md-nav__link">
      TinyHttpd
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      数学
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        数学
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../math/math_graph/" title="图形学相关数学" class="md-nav__link">
      图形学相关数学
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9">
    
    <label class="md-nav__link" for="nav-9">
      图形学
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-9">
        图形学
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../unity/List/" title="规划" class="md-nav__link">
      规划
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unity/unity_base/" title="Unity基础" class="md-nav__link">
      Unity基础
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unity/unity_shader/" title="Shader" class="md-nav__link">
      Shader
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10" type="checkbox" id="nav-10">
    
    <label class="md-nav__link" for="nav-10">
      LeetCode
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-10">
        LeetCode
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../leetcode/1.two-sum/" title="两数之和" class="md-nav__link">
      两数之和
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11" type="checkbox" id="nav-11" checked>
    
    <label class="md-nav__link" for="nav-11">
      经验总结🔧
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-11">
        经验总结🔧
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        临时草稿纸📃
      </label>
    
    <a href="./" title="临时草稿纸📃" class="md-nav__link md-nav__link--active">
      临时草稿纸📃
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c-primer" class="md-nav__link">
    C++ primer学习笔记
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    变量和基本类型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    基本内置类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    复合类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    const限定符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#auto" class="md-nav__link">
    auto类型说明符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decltype" class="md-nav__link">
    decltype类型指示符
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#decltype_1" class="md-nav__link">
    decltype和引用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    字符串，向量和数组
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    string(可变长的字符序列)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    vector(对象的集合)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector_1" class="md-nav__link">
    vector迭代器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    迭代器类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    语句
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#try" class="md-nav__link">
    try语句块与异常处理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    重载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constexpr" class="md-nav__link">
    内联函数和constexpr函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    函数指针
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#constructor" class="md-nav__link">
    构造函数(constructor)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    聚合类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    字面值常量类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    类的静态成员
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    IO库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    顺序容器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    容器适配器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    泛型算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lambda" class="md-nav__link">
    lambda表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    参数绑定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    额外的迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    关联容器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    动态内存
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shared_ptr" class="md-nav__link">
    shared_ptr类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unique_ptr" class="md-nav__link">
    unique_ptr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weak_ptr" class="md-nav__link">
    weak_ptr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#allocator" class="md-nav__link">
    allocator类
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    拷贝控制
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    对象移动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    操作重载与类型转换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    面向对象设计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    模板与泛型编程
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    函数模版
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    类模版
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    其它
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../code_style/" title="编程规范" class="md-nav__link">
      编程规范
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../mkdocs/" title="基于mkdocs的blog搭建" class="md-nav__link">
      基于mkdocs的blog搭建
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../vim/" title="VIM常用技巧" class="md-nav__link">
      VIM常用技巧
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../gdb/" title="GDB调试的基本使用" class="md-nav__link">
      GDB调试的基本使用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tmux/" title="tmux基本技巧" class="md-nav__link">
      tmux基本技巧
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c-primer" class="md-nav__link">
    C++ primer学习笔记
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    变量和基本类型
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    基本内置类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    复合类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    const限定符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#auto" class="md-nav__link">
    auto类型说明符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decltype" class="md-nav__link">
    decltype类型指示符
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#decltype_1" class="md-nav__link">
    decltype和引用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    字符串，向量和数组
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    string(可变长的字符序列)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    vector(对象的集合)
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector_1" class="md-nav__link">
    vector迭代器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    迭代器类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    数组
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    语句
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#try" class="md-nav__link">
    try语句块与异常处理
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    重载
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constexpr" class="md-nav__link">
    内联函数和constexpr函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    函数指针
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    类
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#constructor" class="md-nav__link">
    构造函数(constructor)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    聚合类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    字面值常量类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    类的静态成员
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    IO库
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    顺序容器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    容器适配器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    泛型算法
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lambda" class="md-nav__link">
    lambda表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    参数绑定
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    额外的迭代器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    关联容器
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    动态内存
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shared_ptr" class="md-nav__link">
    shared_ptr类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unique_ptr" class="md-nav__link">
    unique_ptr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weak_ptr" class="md-nav__link">
    weak_ptr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#allocator" class="md-nav__link">
    allocator类
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    拷贝控制
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    对象移动
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    操作重载与类型转换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    面向对象设计
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    模板与泛型编程
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    函数模版
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    类模版
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    其它
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/opfanswyx/StackPub/edit/master/docs/kit/paper.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>临时草稿纸📃</h1>
                
                <h2 id="c-primer">C++ primer学习笔记<a class="headerlink" href="#c-primer" title="Permanent link">&para;</a></h2>
<h3 id="_1">变量和基本类型<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<h4 id="_2">基本内置类型<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p>位(比特序列)(bit,b)，字节(byte,Byte,B)，存储的基本单元为字(word)。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="mi">1</span><span class="n">byte</span> <span class="o">=</span> <span class="mi">8</span> <span class="n">bit</span> 
<span class="err">​​</span><span class="mi">1</span><span class="n">KB</span>   <span class="o">=</span> <span class="mi">1024</span><span class="n">B</span> 
<span class="mi">1</span><span class="n">MB</span>   <span class="o">=</span> <span class="mi">1024</span><span class="n">KB</span> 
<span class="mi">1</span><span class="n">GB</span>   <span class="o">=</span> <span class="mi">1024</span><span class="n">MB</span>
<span class="mi">1</span><span class="n">TB</span>   <span class="o">=</span> <span class="mi">1024</span><span class="n">MB</span>
</pre></div>
</td></tr></table>

<p>赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数<strong>取模后的余数</strong>。</p>
<p><strong>当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数</strong>。</p>
<p>指定字面值类型</p>
<table>
<thead>
<tr>
<th align="center">前缀/后缀</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">u</td>
<td align="center">char16_t</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">char32_t</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">wchar_t</td>
</tr>
<tr>
<td align="center">u8</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">u or U</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long double</td>
</tr>
<tr>
<td align="center">ll or LL</td>
<td align="center">long long</td>
</tr>
</tbody>
</table>
<h4 id="_3">变量<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p><strong>数据类型</strong>决定变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。</p>
<p>变量<strong>定义</strong>：<strong>类型说明符(type specifier)</strong>，随后紧跟一个或多个<strong>变量名</strong>组成的列表，变量名以逗号分隔，最后以分号结束，变量名的类型由类型说明符指定。</p>
<p>变量<strong>初始化</strong>不是<strong>赋值</strong>，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<p>列表初始化用于内置类型的变量时：如果存在初始值丢失信息的风险，则编译器将报错。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">ld</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">ld</span><span class="p">};</span>  <span class="c1">//错误：转换未执行，存在丢失信息风险</span>
<span class="kt">int</span> <span class="nf">c</span><span class="p">(</span><span class="n">ld</span><span class="p">),</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ld</span><span class="p">;</span>    <span class="c1">//正确：转换执行，丢失部分值</span>
</pre></div>
</td></tr></table>
定义函数体内部的内置变量类型将不被<strong>默认初始化</strong>。</p>
<p>变量<strong>声明</strong>规定了变量的类型和名字，除此之外，变量<strong>定义</strong>还申请存储空间，也可能会为变量赋一个初始值。声明一个变量且非定义它，需要在变量名前添加关键字extern，且不要显示初始化该变量。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">//声明</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415</span><span class="p">;</span>  <span class="c1">//extern语句如果包含初始值不再是申明，而变成定义</span>
</pre></div>
</td></tr></table>
变量能且只能被定义一次，但可以被多次声明。</p>
<h4 id="_4">复合类型<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p>复合类型是指基于其他类型定义的类型。</p>
<p>一条声明语句由一个<strong>基本数据类型</strong>(base type)和紧随其后的一个<strong>声明符</strong>(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<p><strong>引用</strong>(reference)并非对象，只是为一个已经存在的对象所起的另外一个名字。引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p>
<p>引用本身不是一个对象，所以不能定义引用的引用，且一旦定义了引用，就无法令其再绑定到另外的对象。</p>
<p>C++程序最好使用<code>nullptr</code>，同时避免使用<code>NULL</code>。</p>
<p>不能定义指向引用的指针，可以定义<strong>对指针的引用</strong>。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>       <span class="c1">//a是一个指针</span>
<span class="kt">int</span> <span class="o">*&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">//p是一个对指针a的引用</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">//p引用了一个指针，给p赋值&amp;i就是令a指向i</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">//解引用p得到i，也就是a指向的对象，将i的值改为0</span>
</pre></div>
</td></tr></table></p>
<h4 id="const">const限定符<a class="headerlink" href="#const" title="Permanent link">&para;</a></h4>
<p>const对象必须初始化。const对象仅在文件内有效。为了让const对象在对文件内有效，可以在const变量不管声明还是定义都添加extern关键字。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">();</span>   <span class="c1">//file.cc</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span><span class="p">;</span>   <span class="c1">//file.h</span>
</pre></div>
</td></tr></table></p>
<p>在初始化<strong>常量引用</strong>(const引用)时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一般表达式。</p>
<p>允许一个常量的指针指向一个非常量对象。</p>
<p><strong>指向常量的指针(pointer to const)</strong>(不能改变其所指对象的值)：const位于*之前。指向常量的指针也没有要求所指的对象必须是一个常量。仅仅要求不能通过该指针改变对象的值，也没有规定那个对象的值不能通过其它途径改变</p>
<p><strong>常量指针(const pointer)</strong>(不变的是指针本身而非指向的那个值)：const关键字位于* 和var之间。const指针必须初始化，且初始化后它的值(存放指针的那个地址)不能在改变。</p>
<p><strong>顶层const</strong>(top-level const)指针本身是个常量。顶层const可以表示任意的对象是常量(如算术类型，类，指针等)。</p>
<p><strong>底层const</strong>(low-level const)指针指向的对象是一个常量。与指针和引用等复合类型有关。</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>       <span class="c1">//不能改变P1的值，这是一个顶层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>        <span class="c1">//不能改变ci的值，这是一个顶层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>      <span class="c1">//允许改变p2的值，这是一个底层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span> <span class="c1">//靠右的const是顶层const，靠左的是底层const</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>        <span class="c1">//用于声明引用的const都是底层const</span>
</pre></div>
</td></tr></table>
执行对象的拷贝操作时，顶层const和底层const常量的区别明显。其中，顶层const不受影响，拷入拷出必须具有相同的底层const资格或者两个对象的数据类型必须能够转换(非常量可以转换成常量，反之则不行)。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>   <span class="c1">//正确:拷贝ci的值，ci是一个顶层const，对此操作无影响。</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>  <span class="c1">//正确:p2和p3指向的对象类型相同，p3顶层const的部分不影响。</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>  <span class="c1">//错误:p3包含底层const的定义。</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>      <span class="c1">//正确:p2和p3都是底层const。</span>
<span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>      <span class="c1">//正确:int*能转换成const int *。</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="c1">//错误:普通的int &amp;不能绑定到int常量上。</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">//正确:const int&amp;可以绑定到一个普通int上。</span>
</pre></div>
</td></tr></table></p>
<p><code>常量表达式</code>指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象是不是常量表达式由它的数据类型和初始值共同决定。</p>
<p><strong>constexpr变量</strong>c++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<p>constexpr声明一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。constexpr把它所定义的对象置为顶层const，constexpr指针既可以指向常量也可以指向一个非常量。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">//p是一个指向整型常量的指针</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">//q是一个指向整数的常量指针</span>
</pre></div>
</td></tr></table></p>
<p>类型别名<code>typedef</code>和<code>using</code>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="kt">double</span> <span class="n">wages</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">wages</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>   <span class="c1">//base是double的同义词，p是double *的同义词</span>

<span class="k">using</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Sales_item</span><span class="p">;</span>
</pre></div>
</td></tr></table></p>
<p>const是对给定类型的修饰。pstring实际上指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</pre></div>
</td></tr></table></p>
<h4 id="auto">auto类型说明符<a class="headerlink" href="#auto" title="Permanent link">&para;</a></h4>
<p>当引用被用作初始值时，真正参与初始化的其实是引用对象的值。编译器以<strong>引用对象的类型作为auto的类型</strong>。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="c1">//a是一个整数(r是i的别名，而i是一个整数)</span>
</pre></div>
</td></tr></table>
auto一般会<strong>忽略掉顶层const</strong>，同时底层const则会保留。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>        <span class="c1">//b是一个整数(ci的顶层const特性被忽略掉了)</span>
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>        <span class="c1">//c是一个整数(cr是ci的别名，ci本身是一个顶层const)</span>
<span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="c1">//d是一个整型指针(整数的地址就是指向整数的指针)</span>
<span class="mf">1.</span> <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>    <span class="c1">//e是一个指向整数常量的指针(对常量对象取地址是一种底层const)</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="c1">//ci的推演类型是int，f是const int</span>
<span class="mf">2.</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">g</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>    <span class="c1">//g是一个整型常量引用，绑定到ci</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">h</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>       <span class="c1">//错误，不能为非常量引用绑定字面值</span>
<span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//可以为常量引用绑定字面值</span>
</pre></div>
</td></tr></table>
设置一个类型为auto的引用时(2)，初始值中的顶层const常量属性仍然保留，如果给初始值绑定一个引用(1)，则此时的常量就不是顶层常量了。</p>
<h4 id="decltype">decltype类型指示符<a class="headerlink" href="#decltype" title="Permanent link">&para;</a></h4>
<p>decltype选择并返回操作数的数据类型。编译器分析表达式的类型，实际不计算表达式的值。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">decltype</span><span class="p">(</span><span class="n">fun</span><span class="p">())</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">//sum的类型就是函数fun()的返回类型</span>
</pre></div>
</td></tr></table>
decltype处理顶层const和引用的方式与auto有些许不同(<strong>引用对象的类型作为auto的类型</strong>)。如果decltype使用的表达式是一个变量,则<strong>decltype返回该变量的类型(包括顶层const和引用在内)</strong>。引用从来都作为其所指对象的同义词出现，只有在decltype处是一个例外。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cj</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">//x的类型时const int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>       <span class="c1">//y的类型时const int&amp;, y绑定到变量x</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">z</span><span class="p">;</span>           <span class="c1">//错误:z是一个引用，必须初始化</span>
</pre></div>
</td></tr></table></p>
<h5 id="decltype_1">decltype和引用<a class="headerlink" href="#decltype_1" title="Permanent link">&para;</a></h5>
<p>decltype使用的表达式不是一个变量，则decltype返回<strong>表达式结果</strong>对应的类型。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">//加法的结果是int，因此b是一个(未初始化的)int</span>
<span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>       <span class="c1">//c是int&amp;,必须初始化</span>
</pre></div>
</td></tr></table>
如果表达式的内容是解引用操作(*)p，则decltype将得到引用类型。</p>
<p>decltype和auto的另一个重要区别是，如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加一层或多层括号，编译器会把它当成一个表达式，decltype就会得到引用的类型。<strong>decltype((variable))</strong>的结果永远是引用，而<strong>decltype(cariable)</strong>结果只有当variable本身就是一个引用时才是引用。</p>
<h3 id="_5">字符串，向量和数组<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>头文件不应包含using声明。</p>
<h4 id="string">string(可变长的字符序列)<a class="headerlink" href="#string" title="Permanent link">&para;</a></h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>如果使用等号(=)初始化一个变量，实际执行的是<strong>拷贝初始化</strong>(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是<strong>直接初始化</strong>(direct initialization)。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>  <span class="c1">//拷贝初始化</span>
<span class="n">string</span> <span class="nf">s3</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">);</span>   <span class="c1">//直接初始化</span>
<span class="n">string</span> <span class="nf">s4</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>    <span class="c1">//直接初始化</span>
</pre></div>
</td></tr></table></p>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了<strong>标准库类型与机器无关的特性</strong>。c++11新标准允许编译器通过auto或者decltype来推断变量的类型<code>auto len = line.size();</code>。注意string::size_type是无符号类型，小心与负值的比较。</p>
<p>string<strong>相等性(==和!=)验证规则</strong>：</p>
<ol>
<li>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应为止上的字符串相同，就说较短string对象小于较长string对象。</li>
<li>如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。</li>
</ol>
<p><strong>字符串字面值</strong>与string是不同的类型，当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">ispunct</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span>  <span class="c1">//引用类型</span>
  <span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">index</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
    <span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</pre></div>
</td></tr></table>

<h4 id="vector">vector(对象的集合)<a class="headerlink" href="#vector" title="Permanent link">&para;</a></h4>
<p>vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。引用不是对象，所以不存在包含引用的vector。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span>               <span class="c1">//v1是一个空vector</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>           <span class="c1">//v2中包含有v1所有元素的副本</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span><span class="p">;</span>          <span class="c1">//等价于v2(v1)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>       <span class="c1">//v3包含了n个重复的元素</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>            <span class="c1">//v4包含了n个重复执行了值初始化的对象</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">...};</span>     <span class="c1">//v5包含了初始值个数的元素,列表初始化</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v5</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">...};</span>  <span class="c1">//等价于v5{a,b,c...}</span>
</pre></div>
</td></tr></table>

<p><strong>vector</strong>不能用下标形式添加元素，只能对确定已存在的元素执行下标操作。</p>
<h5 id="vector_1">vector迭代器<a class="headerlink" href="#vector_1" title="Permanent link">&para;</a></h5>
<p><strong>begin</strong>成员负责返回指向第一个元素的迭代器，<strong>end</strong>成员负责返回指向容器<strong>尾元素的下一个位置</strong>的迭代器，该迭代器指示的是容器的一个本不存在的<strong>尾后元素</strong>(off-the-end iterator)。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。试图解引用一个非法迭代器或者尾后迭代器都是未定义行为。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
  <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<h6 id="_6">迭代器类型<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h6>
<p>如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，则既能使用iterator也能使用const_iterator。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it2</span><span class="p">;</span>  <span class="c1">//读取但不能修改</span>
</pre></div>
</td></tr></table>
如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>   <span class="c1">//vector&lt;int&gt;::iterator</span>
<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//vector&lt;int&gt;::const_iterator</span>
</pre></div>
</td></tr></table>
为了便于专门(不论vector对象本身是否是常量)得到const_iterator类型的返回值，c++11引入了两个新函数，分别是cbegin和cend。</p>
<p><strong>使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</strong>。</p>
<h5 id="_7">数组<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h5>
<p>不能将数组的内容拷贝给其它数组作为初始值，也不能用数组为其他数组赋值。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>              <span class="c1">//含有10个指针的数组</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">?</span><span class="p">;</span>          <span class="c1">//错误</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">parray</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span>   <span class="c1">//parray指向一个含有10个整数的数组</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parrRef</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>   <span class="c1">//parrRef引用一个含有10个整数的数组</span>
<span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span>   <span class="c1">//array是数组的引用，该数组含有10个指针</span>
</pre></div>
</td></tr></table>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">int_arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">int_arr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">int_arr</span><span class="p">));</span>
</pre></div>
</td></tr></table>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">row</span> <span class="p">:</span> <span class="n">ia</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">clo</span> <span class="p">:</span> <span class="n">row</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">col</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
</pre></div>
</td></tr></table></p>
<h3 id="_8">表达式<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>当一个对象被用作<strong>右值</strong>的时候，用的是对象的值(内容)；当对象被用作<strong>左值</strong>的时候，用的是对象的身份(在内存中的位置)。在需要右值的地方可以用左值来替代，但是不能把右值当成左值使用。</p>
<p><strong>左移运算</strong>：m&lt;&lt;n表示把m左移n位，最左边的n位被丢弃，右边补上n个0。00001010&lt;&lt;2=00101000</p>
<p><strong>右移运算</strong>：m&gt;&gt;n表示把m右移n位，最右边的n位被丢弃，左边的情况分两种：</p>
<ol>
<li>如果数字是一个无符号数值，则用0填补最左边的n位。00001010&gt;&gt;2=00000010</li>
<li>如果数字是一个有符号数值，则用数字的符号位填补 最左边的n位。(如果数字是正数，右移之后左边补0，如果是负数，左边补1)。10001010&gt;&gt;3=11110001</li>
</ol>
<p><strong>sizeof</strong>运算符返回一个<strong>表达式</strong>或一个<strong>类型名</strong>所占用的字节数。其所得的值类型是一个size_t类型的常量表达式。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">sizeof</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
<span class="k">sizeof</span> <span class="n">expr</span>   <span class="c1">//sizeof返回的是表达式结果类型的大小。sizeof并不实际计算其运算对象的值。</span>
</pre></div>
</td></tr></table></p>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<ol>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。</li>
<li>对数组执行sizeof运算得到整个数组所占空间大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ol>
<p>因为sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数:
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ia</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">sz</span><span class="p">];</span>
</pre></div>
</td></tr></table></p>
<p><strong>逗号运算符</strong>(comma operator)，按照从左到右的顺序依次求值。首先对左侧的表达式求值，然后将求值结果丢掉，符号运算符真正的结果是右侧表达式的值。如果右侧运算对象的值是左值，那么最终的求值结果也是左值。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">j</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">100</span><span class="p">,</span> <span class="mi">999</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>  <span class="c1">//i = 1010</span>
</pre></div>
</td></tr></table></p>
<p>隐式转换(implicit conversion)
显示类型转换(cast)</p>
<ol>
<li>static_cast，任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</td></tr></table></li>
<li>const_cast只能改变运算对象的底层const，用于把常量对象转换成非常量对象。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
</pre></div>
</td></tr></table></li>
<li>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">chat</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</pre></div>
</td></tr></table></li>
<li>dynamic_cast与运行时类型识别有关。</li>
</ol>
<h3 id="_9">语句<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p><strong>范围for语句</strong>(range for statement)
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="nl">declaration</span> <span class="p">:</span> <span class="n">expression</span><span class="p">)</span>
  <span class="n">statement</span>
</pre></div>
</td></tr></table>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">r</span> <span class="p">:</span> <span class="n">v</span><span class="p">){</span>
  <span class="n">r</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<h4 id="try">try语句块与异常处理<a class="headerlink" href="#try" title="Permanent link">&para;</a></h4>
<ol>
<li>throw表达式(throw expression)异常检测部分使用throw表达式来表示它遇到来无法处理的问题。一般说throw引发(raise)了异常。</li>
<li>try语句块(try block)异常处理部分。try语句块与多个catch子句组成。try语句块中代码抛出的异常通常会被某个catch子句结束。</li>
<li>异常类(exception class)，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li>
</ol>
<h3 id="_10">函数<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>当形参是引用类型时，它对应的实参被<strong>引用传递</strong>(passed by reference)，和其他引用一样，引用形参也是它绑定的对象的别名，使用引用避免拷贝。</p>
<p>当实参的值拷贝给形参时，形参和实参是两个相互独立的对象。对应的实参被<strong>值传递</strong>(passed by value)。</p>
<p>当形参是const时，使用实参初始化形参时会忽略掉顶层const(顶层const作用于对象本身)。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。</p>
<p>可以使用非常量初始化一个底层const对象，但是反过来不行。普通的引用必须用同类型的对象初始化。</p>
<p>由于不能把const对象，字面值或者需要类型转换的对象传递给普通的引用形参，尽量使用常量引用。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]){</span>   <span class="c1">//数组引用形参</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p><strong>initializer_lister</strong>类型的形参用于实参数量未知但是全部实参的类型相同的情况。</p>
<p>调用一个返回引用的函数得到左值，其它返回类型得到右值。可以为返回类型是非常量引用的函数的结果赋值。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">char</span> <span class="o">&amp;</span><span class="n">get_val</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">ix</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="n">ix</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;a value&quot;</span><span class="p">);</span>
  <span class="n">cour</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">get_val</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
c++11规定，函数可以返回<strong>花括号包围的值的列表</strong>。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">expected</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">{};</span>
  <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">expected</span> <span class="o">==</span> <span class="n">actual</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;functionX&quot;</span><span class="p">,</span> <span class="s">&quot;okay&quot;</span><span class="p">};</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;functionX&quot;</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<p>返回数组指针的函数声明<code>int (*func(int i))[10];</code>该声明可以使用类型别名简化。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="n">arrT</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</pre></div>
</td></tr></table>
c++11还有一种简化上述func声明的方法，即<strong>尾置返回类型</strong>(treiling return type)。任何函数的定义都能使用尾置返回。尾置返回类型跟在形参列表后面并以一个<code>-&gt;</code>符号开头。为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个auto：
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组</span>
<span class="k">auto</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</td></tr></table></p>
<p>如果知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">odd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">even</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span> <span class="o">*</span><span class="n">arrPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="c1">//返回一个指向数组的指针</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">add</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">even</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，想表示arrPtr返回指针还必须在函数声明时加一个*符号。</p>
<h4 id="_11">重载<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>顶层const不影响传入函数的对象。一个拥有顶层const和不拥有顶层const无法区分。</p>
<p>某种类型的指针或引用指向的是否是常量可以实现重载，此时的const的底层const。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Phone</span><span class="p">);</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Phone</span><span class="p">);</span>

<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Phone</span> <span class="o">*</span><span class="p">);</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Phone</span> <span class="o">*</span><span class="k">const</span><span class="p">);</span>
<span class="c1">//以下都是构成重载</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Account</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Account</span><span class="o">&amp;</span><span class="p">);</span>

<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Account</span><span class="o">*</span><span class="p">);</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Account</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。通常在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
<h4 id="constexpr">内联函数和constexpr函数<a class="headerlink" href="#constexpr" title="Permanent link">&para;</a></h4>
<p>内联函数(inline)机制用于优化规模较小，流程直接，频繁调用的函数。</p>
<p><strong>constexpr函数</strong>是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都是字面值类型，而且函数体中必须有且只有一条return语句。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">new_sz</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">new_sz</span><span class="p">();</span>
</pre></div>
</td></tr></table>
constexpr函数被隐式的指定为内联函数。constexpr函数体中可以有其他语句，只要这些语句不被运行时执行就行。</p>
<p>内联函数和constexpr函数通常定义在头文件中。</p>
<p>assert是一种预处理宏。首先对expr求值，如果表达式为假(即0)，assert输出信息并且终止程序的执行。如果表达式为真(非0)，assert什么也不做。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">assert</span> <span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<p>除了assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将忽略掉：
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">ia</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">__FUNC__</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: array size is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></p>
<h4 id="_12">函数指针<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="nf">lengthCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
</pre></div>
</td></tr></table>
重载函数指针类型必须与重载函数中的某一个精确匹配。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">ff</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">ff</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf1</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">ff</span><span class="p">;</span>
</pre></div>
</td></tr></table>
函数指针形参，我们可以直接把函数作为实参使用，它会自动转换成指针。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">//第三个参数是函数类型，它会自动的转换成指向函数的指针</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">pf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">));</span>
<span class="c1">//显示的将形参定义成指向函数的指针</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">));</span>
<span class="c1">//自动将函数转换成函数指针</span>
<span class="n">useBigger</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">lengthCompare</span><span class="p">);</span>
</pre></div>
</td></tr></table>
返回指向函数的指针
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">F</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>      <span class="c1">//F是函数类型，不是指针</span>
<span class="k">using</span> <span class="n">PF</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">//PF是指针类型</span>

<span class="n">PF</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">//f1返回指向函数的指针</span>
<span class="n">F</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>      <span class="c1">//错误</span>
<span class="n">F</span> <span class="o">*</span><span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">//显示地指定返回类型是指向函数的指针</span>

<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="c1">//尾置返回类型</span>
<span class="k">auto</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> 
</pre></div>
</td></tr></table>
decltype作用于某个函数时，它返回函数类型而非指针类型，应该显示地加上<code>*</code>以表明我们需要返回指针。</p>
<h3 id="_13">类<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p>类的基本思想是数据<strong>抽象</strong>和<strong>封装</strong>。</p>
<p>默认情况下，this的类型是指向类类型非常量版本的常量指针。</p>
<h4 id="constructor">构造函数(constructor)<a class="headerlink" href="#constructor" title="Permanent link">&para;</a></h4>
<p>构造函数的任务是初始化类对象的数据成员，无论何时只要类对象被创建，就会执行构造函数。</p>
<p>构造函数不能声明为const的，当创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得“常量”属性。</p>
<p>如果类没有显示地定义一个构造函数，则编译器会隐式的定义一个默认构造函数，默认构造函数无须任何实参。</p>
<p>在c++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面加上<strong>= default</strong>来要求编译器生成构造函数，其中= default既可以和声明一起出现在类内部，也可以出现在类外部。</p>
<p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Screen</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">pos</span> <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pos</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">contents</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>
如果类成员是const，引用或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值。</p>
<p>定义在类内部的成员函数是自动inline的。我们可以在类的内部把inline作为声明的一部分显示地声明成函数，也能在类的外部用inline关键字修饰函数的定义。inline成员函数也应该与相应的类定义在同一个头文件中。</p>
<p><strong>委托构造函数</strong>使用所属类的其他构造函数执行它自己的初始化过程，或者把它自己的一些(或全部)职责委托给其他构造函数。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Sales_data</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">//非委托构造函数</span>
  <span class="n">Sales_data</span><span class="p">(</span><span class="nl">std</span><span class="p">:</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">)</span><span class="o">:</span>
      <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">cnt</span><span class="p">),</span> <span class="n">revenue</span><span class="p">(</span><span class="n">cnt</span> <span class="o">*</span> <span class="n">price</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">//其余构造函数委托另一个构造函数</span>
  <span class="n">Sales_data</span><span class="p">()</span> <span class="o">:</span> <span class="n">Sales_data</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Sales_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">Sales_data</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Sales_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">)</span> <span class="o">:</span> <span class="n">Sales_data</span><span class="p">()</span> <span class="p">{</span> <span class="n">read</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
<strong>转换构造函数</strong>只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。</p>
<p>将构造函数加以<strong>explicit</strong>声明，可以抑制构造函数隐式转换。</p>
<h4 id="_14">聚合类<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>聚合类：所有成员都是public的。没有定义任何构造函数。没有类初始值。没有基类，也没有virtual函数。</p>
<h4 id="_15">字面值常量类<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<h4 id="_16">类的静态成员<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<h3 id="io">IO库<a class="headerlink" href="#io" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">头文件</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">iostream</td>
<td align="left">istream,wistream</td>
<td align="left">从流读取数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">ostream,wostream</td>
<td align="left">从流写入数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">iostream,wiostream</td>
<td align="left">读写流</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="left">ifstream,wifstream</td>
<td align="left">从文件读取数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">ofstream,wofstream</td>
<td align="left">向文件写入数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">fstream,wfstream</td>
<td align="left">读写文件</td>
</tr>
<tr>
<td align="center">sstream</td>
<td align="left">istringstream,wistringstream</td>
<td align="left">从string读取数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">ostringstream,wostringstream</td>
<td align="left">向string写入数据</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">stringstream,wstringstream</td>
<td align="left">读写string</td>
</tr>
</tbody>
</table>
<p><strong>IO对象不能拷贝和赋值</strong>，所以不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写IO对象会改变其状态，所以传递和返回引用不能是const的。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">ofstream</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">;</span>
<span class="n">out1</span> <span class="o">=</span> <span class="n">out2</span><span class="p">;</span>              <span class="c1">//错误：不能对流对象赋值</span>
<span class="n">ofstream</span> <span class="nf">print</span><span class="p">(</span><span class="n">ofstream</span><span class="p">);</span> <span class="c1">//错误：不能初始化ofstream参数</span>
<span class="n">out2</span> <span class="o">=</span> <span class="n">print</span><span class="p">(</span><span class="n">out2</span><span class="p">);</span>       <span class="c1">//错误：不能拷贝流对象</span>
</pre></div>
</td></tr></table>

<h3 id="_17">顺序容器<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">vector</td>
<td align="left">可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td>
</tr>
<tr>
<td align="left">deque</td>
<td align="left">双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。</td>
</tr>
<tr>
<td align="left">forward_list</td>
<td align="left">单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度很快。</td>
</tr>
<tr>
<td align="left">array</td>
<td align="left">固定大小数组，支持快速随机访问。不能添加或删除元素。</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入/删除速度块。</td>
</tr>
</tbody>
</table>
<h4 id="_18">容器适配器<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<p>适配器(adaptor)接受一种已有的容器类型，使其行为看起来像一种不同的容器。</p>
<p>顺序容器的适配器：stack，queue和priority_queue。</p>
<h3 id="_19">泛型算法<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p><strong>谓词</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为两类：<strong>一元谓词</strong>只接受单一参数，<strong>二元谓词</strong>有两个参数。</p>
<p>可调用对象：函数，函数指针，lambda表达式，重载了函数调用运算符的类。</p>
<h4 id="lambda">lambda表达式<a class="headerlink" href="#lambda" title="Permanent link">&para;</a></h4>
<p>一个lambda表达式表示一个可调用的代码单元(一个未命名的内联函数)。lambda可能定义在函数内部。</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">[</span><span class="n">capture</span> <span class="n">list</span><span class="p">](</span><span class="n">parameter</span> <span class="n">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="n">type</span> <span class="p">{</span> <span class="n">function</span> <span class="n">body</span> <span class="p">}</span>
</pre></div>
</td></tr></table>
capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)。</p>
<p>捕获列表只能用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p>
<p>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。</p>
<p>除了显示捕获所在函数的变量之外，还可以让编译器根据lambda中的代码推断要使用的变量。捕获列表中使用<strong>&amp;</strong>或<strong>=</strong>。&amp;告诉编译器采用捕获引用的方式，=则表示采用值捕获的方式。</p>
<p>一部分需要值捕获，一部分需要引用捕获，可以混合使用隐式捕获与显示捕获。混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是一个&amp;或=，指定了默认捕获方式为引用或值。</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">biggies</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span>      
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">,</span>
    <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="err">&#39;&#39;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">c</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;});</span>

    <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;});</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
如果需要改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。</p>
<p>可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。</p>
<h4 id="_20">参数绑定<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<h4 id="_21">额外的迭代器<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>插入迭代器，流迭代器，反向迭代器，移动迭代器。</p>
<h3 id="_22">关联容器<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="left">按关键字有序保存元素</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">map</td>
<td align="left">关联数组：保存关键字-值对</td>
</tr>
<tr>
<td align="left">set</td>
<td align="left">关键字即值，只保存关键字的容器</td>
</tr>
<tr>
<td align="left">multimap</td>
<td align="left">关键字可重复出现的map</td>
</tr>
<tr>
<td align="left">multiset</td>
<td align="left">关键字可重复出现的set</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="left">无序集合</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">unordered_map</td>
<td align="left">用哈希函数组织的map</td>
</tr>
<tr>
<td align="left">unordered_set</td>
<td align="left">用哈希函数组织的set</td>
</tr>
<tr>
<td align="left">unordered_multimap</td>
<td align="left">哈希组织的map，关键字可以重复出现</td>
</tr>
<tr>
<td align="left">unordered_multiset</td>
<td align="left">哈希组织的set，关键字可以重复出现</td>
</tr>
</tbody>
</table>
<h4 id="pair">pair类型<a class="headerlink" href="#pair" title="Permanent link">&para;</a></h4>
<h3 id="_23">动态内存<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<p>shared_ptr,unique_ptr,weak_ptr.</p>
<h4 id="shared_ptr">shared_ptr类<a class="headerlink" href="#shared_ptr" title="Permanent link">&para;</a></h4>
<p><strong>make_shared</strong>函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vecotr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">();</span>  <span class="c1">//指向一个动态分配的空vector&lt;string&gt;</span>

<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>
</pre></div>
</td></tr></table>
当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。每个shared_ptr都有一个关联的计数器，称其为<strong>引用计数</strong>。当一个shared_ptr的计数器变为0，它就会释放自己所管理的对象。</p>
<h4 id="unique_ptr">unique_ptr<a class="headerlink" href="#unique_ptr" title="Permanent link">&para;</a></h4>
<p>某个时刻只有一个unique_ptr指向一个给定的对象。不支持普通的拷贝或赋值操作。可以通过release或reset将指针的所有权从一个(非const)unique_ptr转移给另一个unique。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> 
<span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</pre></div>
</td></tr></table>
release成员返回unique_ptr当前保存的指针并将其置为空。p2被初始化为p1原来保存的指针，而p1被置为空。</p>
<p>reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。</p>
<p>可以拷贝或赋值一个将要被销毁的unique_ptr。</p>
<h4 id="weak_ptr">weak_ptr<a class="headerlink" href="#weak_ptr" title="Permanent link">&para;</a></h4>
<p>weak_ptr是一种不控制所指向对象生存期的智能指针，他指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">w.reset()</td>
<td align="left">将w置为空</td>
</tr>
<tr>
<td align="left">w.use_count()</td>
<td align="left">与w共享对象的shared_ptr的数量</td>
</tr>
<tr>
<td align="left">w.expired()</td>
<td align="left">当w.use_count()为0，返回true，否则返回false</td>
</tr>
<tr>
<td align="left">w.lock()</td>
<td align="left">当expired为true，返回一个空shared_ptr,否则返回一个指向w的对象的shared_ptr</td>
</tr>
</tbody>
</table>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">()){</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="allocator">allocator类<a class="headerlink" href="#allocator" title="Permanent link">&para;</a></h4>
<p>new将内存分配和对象构造组合在一起，delete将对象析构和内存释放组合在一起。</p>
<p>allocator帮助我们将内存分配和对象构造分离开来。是一种类型感知的内存分配方法，它分配的内存是原始的，未构造的。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">allocator<T> a</td>
<td align="left">定义一个名为a的allocator对象，可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td align="left">a.allocate(n)</td>
<td align="left">分配一段原始的，未构造的内存，保存n个类型为T的对象</td>
</tr>
<tr>
<td align="left">a.deallocate(p,n)</td>
<td align="left">释放从T*指针p中地址开始的内存，这块内存保存类n个类型为T的对象，p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用 deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td align="left">a.construct(p, args)</td>
<td align="left">p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</td>
</tr>
<tr>
<td align="left">a.destroy(p)</td>
<td align="left">p为T*类型的指针，此算法对p指向的对象执行析构函数</td>
</tr>
</tbody>
</table>
<h3 id="_24">拷贝控制<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<p><strong>拷贝构造函数</strong>和<strong>移动构造函数</strong>定义类当用同类型的另一个对象<strong>初始化</strong>本对象时做什么。</p>
<p><strong>拷贝赋值运算符</strong>和<strong>移动赋值运算符</strong>定义类一个对象<strong>赋予</strong>同类型的另一个对象时做什么。</p>
<p>拷贝构造函数第一个参数是自身类类型的引用，且任何额外参数都有默认值。虽然可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const引用。拷贝构造函数常被隐式地使用，通常不应该是explicit的。</p>
<h4 id="_25">对象移动<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h4>
<p>标准库容器，string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<p><strong>右值引用</strong>必须绑定到右值的引用。只能绑定到一个将要销毁的对象。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>     
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>   
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>           <span class="c1">//不能将一个右值引用绑定到一个左值上</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span>       <span class="c1">//i * 42是一个右值</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">//可以将一个const的引用绑定到一个右值上</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span><span class="mi">42</span><span class="p">;</span>
</pre></div>
</td></tr></table>
变量是左值，不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span> <span class="o">=</span> <span class="n">rr1</span><span class="p">;</span>  <span class="c1">//错误：表达式rr1是左值。</span>
</pre></div>
</td></tr></table></p>
<p>新标准库中<strong>move</strong>函数可以获取绑定到左值上的右值引用。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rr1</span><span class="p">);</span>
</pre></div>
</td></tr></table></p>
<p>类似拷贝构造函数，移动构造函数第一个参数是该类型的一个引用。该引用是一个右值引用。移动构造函数必须确保移后源对象处于这样一个状态--销毁后是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源--这些资源的所有权已经归属新创建的对象。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">StrVec</span><span class="o">::</span><span class="n">StrVec</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">noexcept</span> <span class="c1">//移动操作不应抛出任何异常</span>
<span class="c1">//成员初始化器接管s中的资源</span>
  <span class="o">:</span> <span class="n">elements</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">elements</span><span class="p">),</span> <span class="n">first_free</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">first_free</span><span class="p">),</span> 
  <span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">s</span><span class="p">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">first_free</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">cap</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">StrVec</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">free</span><span class="p">();</span>
    <span class="n">elements</span>    <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">elements</span><span class="p">;</span>
    <span class="n">first_free</span>  <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first_free</span><span class="p">;</span>
    <span class="n">cap</span>          <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">cap</span><span class="p">;</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">elements</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first_free</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">cap</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
如果一个类既有移动构造函数，也有拷贝构造函数则<strong>移动右值，拷贝左值</strong>，如果没有移动构造函数，右值也被拷贝。</p>
<p>可以通过标准库的<strong>make_move_iterator</strong>函数将一个普通迭代器转换为一个<strong>移动迭代器</strong>。</p>
<h3 id="_26">操作重载与类型转换<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>当运算符作用于类类型的运算对象时，可以通过重载重新定义该运算符的含义。</p>
<h3 id="_27">面向对象设计<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p>面向对象程序设计的核心思想是数据抽象，继承和动态绑定。</p>
<p>在c++中，当我们使用基类的引用(或指针)调用一个虚函数时将会发生动态绑定。</p>
<h3 id="_28">模板与泛型编程<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h3>
<h4 id="_29">函数模版<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h4>
<h4 id="_30">类模版<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h4>
<h3 id="_31">其它<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
                
                  
                
              
              
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
var gitalk = new Gitalk({
  clientID: '15c136d340d3fcee74f4', 

  clientSecret: '3f4fef6e6bc874fc99b0ee567d79e22ea20695e8', 

  repo: 'StackPubTalk',
  owner: 'opfanswyx',
  admin: ['opfanswyx'],

  id: location.href,      
  distractionFreeMode: false  
})

gitalk.render('gitalk-container')
</script>




              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../leetcode/1.two-sum/" title="两数之和" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                两数之和
              </span>
            </div>
          </a>
        
        
          <a href="../code_style/" title="编程规范" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                编程规范
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2018 - 2019 <a href="https://github.com/opfanswyx">Atticus</a> <br><span class="md-footer-custom-text">博客内容遵守:</span> <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0 协议条款</a>
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="mailto:opfanswyx@outlook.com" class="md-footer-social__link fa fa-envelope"></a>
    
      <a href="https://github.com/opfanswyx" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://t.me/stackpub" class="md-footer-social__link fa fa-telegram"></a>
    
      <a href="//shang.qq.com/wpa/qunwpa?idkey=2ffaaf5a3df5fbb57aa50e84469c9eff6c7a960b4ca4b893317c8583398eb6be" class="md-footer-social__link fa fa-qq"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.ac79c3b0.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="../../_static/js/extra.js?v=15"></script>
      
        <script src="../../_static/js/baidu-tongji.js"></script>
      
        <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>