## C++引用
引用在定义时需要添加&，在使用时不能添加&，使用时添加&表示取地址。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。
### 指针和引用的区别
1. 引用必须在定义时初始化，不能再指向其他数据；指针没有这个限制，指针在定义时不必赋值，也能指向任意数据。
2. 有 const 指针，但是没有 const 引用。
3. 指针可以有多级，但是引用只能有一级。
4. 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1。

### const和引用的奇妙反应
#### 引用不能绑定到临时数据
指针就是数据或代码在内存中的地址，指针变量指向的就是内存中的数据或代码。指针只能指向内存，不能指向寄存器或者硬盘，因为寄存器和硬盘没法寻址。

int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

常量表达式的值虽然在内存中，但是没有办法寻址，所以也不能使用&来获取它的地址，更不能用指针指向它。

引用不能指代临时数据如函数参数等。

临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们。

编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。

给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据(const引用与转换类型)，它们背后的机制都是临时变量。

引用类型的函数形参请尽可能的使用const。