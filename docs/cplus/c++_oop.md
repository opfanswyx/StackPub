## 类与对象
### 类的定义
类的基本思想是数据**抽象**和**封装**。

默认情况下，this的类型是指向类类型非常量版本的常量指针。c++允许把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针。这样使用const的成员函数称为常量成员函数。常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

struct与class定义类的唯一区别是默认的访问权限不一样。使用struct关键字，则定义在第一个访问说明符之前的成员是public的，相反，使用class关键字，则这些成员是private。

### 类的访问控制与封装
#### 友元

类可以允许其他类或者函数访问它的非公有成员，方式是令其他类或者函数成为它的友元(friend)。一般来说最好在类开始或者结束前的位置集中声明友元。

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。通常把友元的声明与类本身放置在同一个头文件中。

如果一个类指定类友元类，则友元类的成员函数可以访问此类包含非公有成员在内的所有成员。

如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

### 构造函数
构造函数的任务是初始化类对象的数据成员，无论何时只要类对象被创建，就会执行构造函数。

构造函数不能声明为const的，当创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得“常量”属性。

如果类没有显示地定义一个构造函数，则编译器会隐式的定义一个默认构造函数，默认构造函数无须任何实参。

在c++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面加上**= default**来要求编译器生成构造函数，其中= default既可以和声明一起出现在类内部，也可以出现在类外部。如果=default在类的内部，则默认构造函数是内联的，如果在内的外部，则默认是不内联的。

如果类成员是const，引用或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值。
#### 默认构造函数

#### 构造函数的初始值列表

#### 委托构造函数
**委托构造函数**使用所属类的其他构造函数执行它自己的初始化过程，或者把它自己的一些(或全部)职责委托给其他构造函数。
```cpp
class Sales_data{
public:
  //非委托构造函数
  Sales_data(std:string s, unsigned cnt, double price):
      bookNo(s), units_sold(cnt), revenue(cnt * price) {}
  //其余构造函数委托另一个构造函数
  Sales_data() : Sales_data("", 0, 0) {}
  Sales_data(std::string s) : Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is) : Sales_data() { read(is, *this);}
}
```
**转换构造函数**只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。

将构造函数加以**explicit**声明，可以抑制构造函数隐式转换。
#### 转换构造函数(隐式类类型转换)


### 重载/内联成员函数
##### 使成员函数作为内联函数
定义在类内部的成员函数是自动inline的。我们可以在类的内部把inline作为声明的一部分显示地声明成函数，也能在类的外部用inline关键字修饰函数的定义。inline成员函数也应该与相应的类定义在同一个头文件中。

##### 重载成员函数
成员函数也可以被重载。

### 可变数据成员
可以通过在变量声明为mutable关键字，修改某个数据成员，即使是在一个const成员函数内。一个可变数据成员永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。
```cpp
class Screen {
public:
  void some_member() const;
private:
  mutable size_t access_ctr;
}

void Screen::some_member() const
{
  ++access_ctr;
}
```

### 类类型
每个类定义唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。

就像可以把函数的声明和定义分离开，也能仅声明类而暂时不定义它，这种声明被称为前向声明(forward declaration)，对于这种类型来说，在它声明之后定义之前是一个不完全类型。

不完全类型使用场景有限，可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数或者返回类型的函数。

**类的成员的类内初始值，从成员函数返回*this**。

### 类型成员
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。类型成员通常在类开始的地方。

```cpp
class Screen{
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

### 聚合类
聚合类：所有成员都是public的。没有定义任何构造函数。没有类初始值。没有基类，也没有virtual函数。
### 字面值常量类

### 类的静态成员


### 拷贝控制与销毁操作
**拷贝构造函数**和**移动构造函数**定义类当同类型的另一个对象**初始化**本对象时做什么。

**拷贝赋值运算符**和**移动赋值运算符**定义类将一个对象**赋予**同类型的另一个对象时做什么。

**析构函数**定义类对象销毁时做什么。


### 拷贝控制与资源管理

### 交换操作

### 动态内存管理类

### 对象移动
标准库容器，string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。

**右值引用**必须绑定到右值的引用。只能绑定到一个将要销毁的对象。
```cpp
int i = 42;     
int &r = i;   
int &&rr = i;           //不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;       //i * 42是一个右值
const int &r3 = i * 42; //可以将一个const的引用绑定到一个右值上
int &&rr2 = i *42;
```
变量是左值，不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。
```cpp
int &&rr1 = 42;
int &&rr2 = rr1;  //错误：表达式rr1是左值。
```

新标准库中**move**函数可以获取绑定到左值上的右值引用。
```cpp
int &&rr3 = std::move(rr1);
```

类似拷贝构造函数，移动构造函数第一个参数是该类型的一个引用。该引用是一个右值引用。移动构造函数必须确保移后源对象处于这样一个状态--销毁后是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源--这些资源的所有权已经归属新创建的对象。
```cpp
StrVec::StrVec(StrVec &&s) noexcept //移动操作不应抛出任何异常
//成员初始化器接管s中的资源
  : elements(s.elements), first_free(s.first_free), 
  cap(s.cap)
{
  s.elements = s.first_free = s.cap = nullptr;
}
```
不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。
```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
  if(this != &rhs)
  {
    free();
    elements    = rhs.elements;
    first_free  = rhs.first_free;
    cap          = rhs.cap;
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }
  return *this;
}
```
如果一个类既有移动构造函数，也有拷贝构造函数则**移动右值，拷贝左值**，如果没有移动构造函数，右值也被拷贝。

可以通过标准库的**make_move_iterator**函数将一个普通迭代器转换为一个**移动迭代器**。

## 运算符重载与类型转换
### 输入输出运算符
### 算术与关系运算符
### 赋值运算符
### 下标运算符
### 递增递减运算符
### 成员访问运算符
### 函数调用运算符

## 继承与派生
### 多继承与虚继承

## 多态与虚函数



## 模板与泛型编程
### 模板实参推断
### 重载与模板
### 可变参数模板
### 模板特例化

## C++异常
1. throw表达式(throw expression)异常检测部分使用throw表达式来表示它遇到来无法处理的问题。一般说throw引发(raise)了异常。
2. try语句块(try block)异常处理部分。try语句块与多个catch子句组成。try语句块中代码抛出的异常通常会被某个catch子句结束。
3. 异常类(exception class)，用于在throw表达式和相关的catch子句之间传递异常的具体信息。


## 运行时类型识别

## 固有的不可移植的特性

