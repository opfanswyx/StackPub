## C++基础
### 命名空间

### 变量与基本类型
位(比特序列)(bit,b)，字节(byte,Byte,B)，存储的基本单元为字(word)。

```c
1byte = 8 bit 
​​1KB   = 1024B 
1MB   = 1024KB 
1GB   = 1024MB
1TB   = 1024MB
```

赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数**取模后的余数**。

**当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数**。
#### 变量
**数据类型**决定变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。

变量**定义**：**类型说明符(type specifier)**，随后紧跟一个或多个**变量名**组成的列表，变量名以逗号分隔，最后以分号结束，变量名的类型由类型说明符指定。

变量**初始化**不是**赋值**，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

列表初始化用于内置类型的变量时：如果存在初始值丢失信息的风险，则编译器将报错。
```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld};  //错误：转换未执行，存在丢失信息风险
int c(ld), d = ld;    //正确：转换执行，丢失部分值
```
定义函数体内部的内置变量类型将不被**默认初始化**。

变量**声明**规定了变量的类型和名字，除此之外，变量**定义**还申请存储空间，也可能会为变量赋一个初始值。声明一个变量且非定义它，需要在变量名前添加关键字extern，且不要显示初始化该变量。
```c++
extern int i;   //声明
extern double pi = 3.1415;  //extern语句如果包含初始值不再是申明，而变成定义
```
变量能且只能被定义一次，但可以被多次声明。

#### 复合类型

复合类型是指基于其他类型定义的类型。

一条声明语句由一个**基本数据类型**(base type)和紧随其后的一个**声明符**(declarator)列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

**引用**(reference)并非对象，只是为一个已经存在的对象所起的另外一个名字。引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。

引用本身不是一个对象，所以不能定义引用的引用，且一旦定义了引用，就无法令其再绑定到另外的对象。

C++程序最好使用```nullptr```，同时避免使用```NULL```。

不能定义指向引用的指针，可以定义**对指针的引用**。
```c++
int i = 42;
int *a;       //a是一个指针
int *&p = a;  //p是一个对指针a的引用
p = &i;       //p引用了一个指针，给p赋值&i就是令a指向i
*p = 0;       //解引用p得到i，也就是a指向的对象，将i的值改为0
```

#### const限定符
const对象必须初始化。const对象仅在文件内有效。为了让const对象在对文件内有效，可以在const变量不管声明还是定义都添加extern关键字。
```c
extern const int bufSize = fcn();   //file.cc
extern const int bufSize;   //file.h
```

在初始化**常量引用**(const引用)时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一般表达式。

允许一个常量的指针指向一个非常量对象。

**指向常量的指针(pointer to const)**(不能改变其所指对象的值)：const位于*之前。指向常量的指针也没有要求所指的对象必须是一个常量。仅仅要求不能通过该指针改变对象的值，也没有规定那个对象的值不能通过其它途径改变

**常量指针(const pointer)**(不变的是指针本身而非指向的那个值)：const关键字位于* 和var之间。const指针必须初始化，且初始化后它的值(存放指针的那个地址)不能在改变。

**顶层const**(top-level const)指针本身是个常量。顶层const可以表示任意的对象是常量(如算术类型，类，指针等)。

**底层const**(low-level const)指针指向的对象是一个常量。与指针和引用等复合类型有关。

```c
int i = 0;
int *const p1 = &i;       //不能改变P1的值，这是一个顶层const
const int ci = 42;        //不能改变ci的值，这是一个顶层const
const int *p2 = &ci;      //允许改变p2的值，这是一个底层const
const int *const p3 = p2; //靠右的const是顶层const，靠左的是底层const
const int &r = ci;        //用于声明引用的const都是底层const
```
执行对象的拷贝操作时，顶层const和底层const常量的区别明显。其中，顶层const不受影响，拷入拷出必须具有相同的底层const资格或者两个对象的数据类型必须能够转换(非常量可以转换成常量，反之则不行)。
```c
i = ci;   //正确:拷贝ci的值，ci是一个顶层const，对此操作无影响。
p2 = p3;  //正确:p2和p3指向的对象类型相同，p3顶层const的部分不影响。

int *p = p3;  //错误:p3包含底层const的定义。
p2 = p3;      //正确:p2和p3都是底层const。
p2 = &i;      //正确:int*能转换成const int *。
int &r = ci;  //错误:普通的int &不能绑定到int常量上。
const int &r2 = i;  //正确:const int&可以绑定到一个普通int上。
```

```常量表达式```指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象是不是常量表达式由它的数据类型和初始值共同决定。

**constexpr变量**c++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

constexpr声明一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。constexpr把它所定义的对象置为顶层const，constexpr指针既可以指向常量也可以指向一个非常量。
```c++
const int *p = nullptr;     //p是一个指向整型常量的指针
constexpr int *q = nullptr; //q是一个指向整数的常量指针
```

类型别名```typedef```和```using```
```c++
typedef double wages;
typedef wages base, *p;   //base是double的同义词，p是double *的同义词

using SI = Sales_item;
```

const是对给定类型的修饰。pstring实际上指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。
```c++
typedef char *pstring;
const pstring cstr = 0;
const pstring *ps;
```
### 字符串，向量和数组
#### string
#### vector
#### 数组
##### 多维数组

### 表达式
#### 位运算
#### sizeof运算符
#### 逗号运算符
#### 类型转换

### 语句

### 函数
#### 参数
#### 函数匹配
#### 函数指针
#### 函数重载

### IO与文件操作
#### IO类
#### 文件输入输出
#### string流

## OOP面向对象

### 类与对象
#### 构造函数
#### 静态成员

### 继承与派生

### 多态与虚函数


## STL(标准模板库)
### 容器
### 容器适配器
### 迭代器
### 算法

## 运算符重载
### 输入输出运算符
### 算术与关系运算符
### 赋值运算符
### 下标运算符
### 递增递减运算符
### 成员访问运算符
### 函数调用运算符 

## 模板与泛型编程
### 模板实参推断
### 重载与模板
### 可变参数模板
### 模板特例化

## C++异常

## 其他
